Context Switching 이란 무엇일까 ?

우선 Context란 무엇일까 ?

사전적 의미를 보자면 문맥(Context)이다.

ex:
A는 17살된 고등학생이다.
B는 A의 아버님이다.

어느날 한밤중 A가 B 몰래 몰컴을 하고 있었다.
A가 하던 게임은 실시간 게임이 아닌 FF같은 턴제 게임이였다.
새벽 3시쯤 B의 방에서 문이 열리는 소리가 들렸고
A는 그 소리를 들었다.

이때 A가 여러분이라면 어떤 행동을 취할 것인가 ?

A는 B가 다가오는 것을 느끼고
하던 게임을 멈추고 모니터를 끈 다음
침대에 누워서 자는 척을 할 것이다.

이후 B가 문을 열고 방안을 주시할 것이다.
별 문제가 없다면 문을 닫고 돌아갈 것이며
B의 귀환을 확인한 A는 다시 일어나서
모니터를 키고 게임을 재개할 것이다.

B가 다가오는 것: Interrupt(인터럽트), Event(이벤트)
하던 게임을 멈추고 모니터를 끈 다음 침대에 누워서 자는 척:
위 행위는 이벤트를 수신한 직후
이 이벤트를 어떤식으로 다룰지에 대한 Handler(핸들러)에 해당한다.

* Interrupt 혹은 Event가 발생하면
  현재 구동중인 모든 작업을 중단하고
  이 Interrupt 혹은 Event를 처리하러 간다(최우선 과제)

B의 귀환: 이벤트 처리(핸들러)의 동작이 완료됨
A가 다시 일어나서 모니터를 키고 게임을 재개함:
멈춰놨던 작업을 다시 시작하는 형태

문제는 내가 어디까지 했지 ??????? 
내가 현재 무엇을 어디까지 얼마나 했는지에 대한 정보: Context



어제 내용을 살짝 개조해서 추가적으로 살펴보자!
(이번에는 변수 이름에 x를 붙여서 실제 HW 레지스터임을 강조)

즉 SW를 활용하여 Mutex를 걸어
공유 변수의 공유를 막는것과는 다른 개념이다.
(HW는 애초에 공유를 하지 않으면 사용이 불가능하기 때문)

1:  ax = 5               1:  ax = 4
2:  bx = ax + cx         2:  bx = ax * 2
3:  cx = 3               3:  cx = ax + bx
     
    Thread A                 Thread B

1) B가 1번까지 내용을 진행했다.
2) 그리고 제어권이 A로 넘어간다.
3) A도 1번까지 내용을 진행하고 제어권이 다시 B로 넘어간다.

Q: 그런대 어떻게 B가 다음에 2번을 실행하는지 아는거지 ???
A: 일단 다음에 실행할 명령은 ip 레지스터에 저장된다.
   그리고 레지스터의 모든 내용을 보관하는 것이 Context 였다.
   결국 Context를 보고 어디를 해야하는지 알 수 있다.

4) B가 이제 2번을 실행한다.

이 경우 bx에는 올바른 값이 들어가는가 ?

결국 태스크(프로세스, 스레드)가 생성될때마다
Context를 저장할 수 있는 객체가 만들어진다.
자기 자신의 Context를 자신이 관리하는 형시으로 가면 어떨까 ?

지금 이 일련의 과정이 Context Switching이다.
결론적으로 자기 자신의 Context는 자신이 관리하는 구조!



* Mutex vs Spinlock

- spinlock pseudo code

for(;;) {
  while(lock) {
    doit!
  }
}

누가 더 좋을까 ?

A1: Mutex 더 좋아보인다.
A2: Spinlock은 자원 낭비다.
RA: 그때 그때 달라요 ~

Mutex 계열이 Lock을 획득하고 있으면
다른 스레드가 접근했을때 들어갈 수 없네 ?
그럼 CPU가 알아서 다른 태스크에게 일을 시킨다.
(그 뜻은 ? Context Switching이 발생한다는 뜻)

Spinlock은 Lock을 획득하고 있었더니
다른 스레드가 접근했을때 마찬가지로 들어갈 수 없네 ?
근대 CPU가 주어진 시간이 만료될때까지 버티고 있네 ?

결론: 단순 작업 - Spinlock 승
     복잡한 작업 - Mutex 승

단순 작업이란 ?

Context Switching은
모든 레지스터 정보, 태스크 정보, 메모리 관련 정보를 저장한다.
(대충 봐도 저장할 분량이 많다는 것을 알 수 있다)
수치적으로 비용을 계산해보는 것이다.
대략 레지스터 -> 메모리로 가는 연산이
10 clock 정도를 소요한다 가정한다.
인텔은 레지스터가 14개니까
대충 레지스터 옮기는 작업만 140 clock이 소요됨
나머지가 추가로 소요를 하게 되는데 
모든 CPU의 특성상 레지스터 -> 레지스터 연산은 1 clock으로 처리된다.
만약 처리하는 작업이 ax = bx + cx 같은 코드라면
단순히 1 clock이 소요된다고 판정할 수 있다.













