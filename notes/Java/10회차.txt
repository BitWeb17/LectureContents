9회차 응용 문제 풀이에 대한 질의 응답!

Q: RockPaperScissors class에서 
   int 값을 주지 않고 String 값을 주어서 비교하여 승리 판독이 가능한가요 ?
   ex) 1=가위,2=바위,3=보 ------> 가위,바위,보
A: String 값을 줘서도 가능하다.
   다만 문자열 값을 비교할때는 == 을 사용하지 않고
   어제 배우지 않은 부분을 사용했다고 얘기했던 equals를 사용하면 된다.
   ex) A 와 B 를 비교한다면 A.equals(B)

Q: WorkRate class에서 requiredMinute 구하는 식 (56번째 줄)
   구조 한번더 설명 부탁드리겠습니다!요
A: 일단 코드는 아래와 같다.
   requiredMinute = ((int)(totalHour * 10) % 10) * 6;
   먼저 시간값을 분으로 만드는 방법에 대해 생각해봐야 한다.
   예로 0.5 시간이면 60 * 5 / 10 의 형태일 것이다.
   결국 0.5 시간이면 30 분이 된다.
   우리는 0.6 시간이었으므로 60 * 0.6 = 60 * 6 / 10 형식이 되어 36분이다.

   코드 관점에서는 먼저 totalHour 가 float 형이다.
   문제는 나머지 연산은 float에 적용되지 않는다는 것이다.
   그러므로 강제로 전체 식에 10 을 곱하고 나중에 다시 10을 나누는 형식을 취한다.
   10 / 10 을 곱한 것이므로 전체 식에 변화는 없다.
   ex) 297.6 이라고 한다면 여기서 % 10 연산을 사용할 경우
       7.6이 아닌 7이 나오게 된다.
   그렇다면 297.6 * 10 을 하면 2976이 되고
   여기서 % 10을 하면 6이 남게 된다.
   원래는 60 * 6 / 10 을 해야하는데
   이미 10 을 곱해버렸으므로 6만 곱한다.
   (뒤에 6 / 10 은 0.6 이니까)

Q: Getter & Setter 한 번 더 설명이 필요함
A: Getter 는 클래스 내부의 값을 얻고자 할 때 사용한다.
   Setter 는 클래스 내부의 값을 셋팅(설정)하고자 할 때 사용한다.
   (오염도가 높아질 수 있기 때문에 되도록이면 설정은 생성자에서 하고
    불가피 하다면 값을 설정하는 루틴을 가진 매서드를 만드는것이 제일 좋다)

Q: Homework9의 69 ~ 83 번째 줄의 for문이 3번 반복을 하면
   총 3개의 ScoreCalculator객체가 생성이 되는 것인가요?
A: 네 맞습니다.
   그림으로 표현한다면 요렇게

   ------------------------------
   | ScoreCalculator Class Type | <--- scArr[0]
   ------------------------------

   ------------------------------
   | ScoreCalculator Class Type | <--- scArr[1]
   ------------------------------

   ------------------------------
   | ScoreCalculator Class Type | <--- scArr[2]
   ------------------------------

   즉 각각이 서로 다른 클래스 객체를 가지고 있는 형식임.
   [0] 이 바뀌어도 [1], [2] 은 영향을 받지 않음
   서로 독립적입니다.

Q: 그렇다면 반복문이 3번 돌아가는 동안
   scArr[0].getMean() -> scArr[1].getMean() -> scArr[2].getMean()
   scArr.getMean()은 3번의 호출이 일어나는 것인가요?
A: 네, 클래스 내부에서 사용되는 매서드는 메모리의 낭비가 발생하지 않도록
   모두 text 라는 공간에서 관리되고 같은 매서드가 호출되도록 처리합니다.
   그러나 내부의 내용물을 다를 수 있습니다(데이터)
   (매서드는 공용으로 사용한다는 뜻)

Q: Homework9의 88 번째 줄의 메서드의 인자로
   객체를 보낸다는 것이 아직 잘이해가 안갑니다.
   당장은 해당 클래스의 데이터를 이용할 수 있다는 정도를 외우고 있지만
   왜 그런것인지에 대해 알고싶습니다.
A: 일단 예로서 int 가 인자로 넘어가는 상황과
   객체 자체가 인자로 넘어가는 상황 두 개를 비교해보도록 합니다.

1번 케이스

   WorkRate wr = new WorkRate(10, 100, 20, 50, 10);

   wr.printInfo();
   wr.calcRemainHour(3);

   위의 형식을 그림으로 표현해보자면 아래와 같다.

           -----------------------   해당 매서드가 사용할 값으로 3을 보냄
   wr ---> | WorkRate Class Type | <-------------------------
           -----------------------                          |
                     ^                                      |
   wr.printInfo() ---|  Inner printInfo() Call              |
                                                   wr.calcRemainHour(3)


2번 케이스

   public static void printMax(ScoreCalculator[] arr)
                                         ^
                                         |
   printMax(scArr);  --------------------|
                          ScoreCalculator 로 구성된 배열을 입력 받음
                          그러므로 입력 인자로 넘어온
                          arr 는 1 번 케이스의 역할을 수행할 수 있다.

Q: Homework11의 23 생성자를 통해 초기화를 하는 경우와
   해당 클래스에서 변수를 선언하고
   바로 초기화 하는 경우는 각각 어떨 때인가요?
   클래스를 재사용하는 경우가 없이
   그 변수는 그 클래스 안에서만 사용한다면
   생성자를 통해 변수를 초기화할 필요가 없는건가요??
A: 되도록이면 클래스 내부에서 변수를 선언하고
   바로 초기화하여 사용하는 케이스는 지양하는 것이 좋습니다.
   혼자 개발하는 경우라면 큰 문제가 없겠으나
   여러 사람이 함께 협업을 하는 케이스에서는
   결국 이런 부분들이 유지보수를 어렵게 만듭니다.
   값의 초기화는 무조건적으로 생성자에서 진행하도록 만들어주는 것이 좋습니다.

Q: My dice 75번째 줄 switch (octahedronDice) case 2에서
   for( int j = i - 1; j >= 0; j--) 반복문이
   왜 이전의 합을 얻은 사람들인가?
A: 현재 주사위를 굴리고 있는 로직이 아래와 같아서 그렇습니다.
   playOctahedron 매서드에서 최초 반복문이 아래와 같습니다.
   for(int i = 0; i < playerNum; i++)
   즉 다음 플레이어가 주사위를 굴리면 i 값이 상승합니다.
   그렇다면 자기 자신을 제외한 현재까지 굴린 사람들은
   현재 i 값에서 - 1 을 해야할 겁니다.
   (현재 i 값은 자기 자신이니)
   그리고 i 값이 커지면서 자신의 차례가 온 것이므로
   이전의 작은 값들은 자신이 아닌 다른 사용자들이겠죠.

Q: RockSissosPaper final int을 하면 오류가 생기는데
   public static final int으로 하면 오류가 사라진다 ?
A: 잠시 보류

Q: 아래 코드에 대한 내용이 이해가 안감
   public void allocate_random_number_to_array() {
        for(int i = 0; i < random_array.length; i++) {
            random_array[i] = (int)(Math.random() * RANGE_VALUE) + BIAS_VALUE;
            index_array[i] = i; // index_array[i]가 왜 i가 되는가??
        }
    }

A: 이런 경우는 문제를 복합적으로 봐야합니다.
   일단 문제를 푸는 방식에 두 가지가 있었는데
   그 중 배열을 관리하는 방식을 선택했습니다.

// ex)   123     64     23    345     10
//       [0]    [1]    [2]    [3]    [4]
//       여기서 23 을 지우면
//       123     64    345     10: 숫자를 다 땡기던
//                     혹은
//       123     64           345     10
//       [0]    [1]           [3]    [4]: 배열 번호를 관리하던

   결국 index_array[i] = i 는 실제 배열의 인덱스 번호를 저장하게 되어 있다.
   좀 더 복잡한 연산이 존재할 경우 del_index_arr 를 만들어서
   지워진 인덱스를 관리하면 더 좋다.

Q: public void delete_random_number_value() {
        random_pick = (int)(Math.random() * number_of_random);

        System.out.println("지워진 값 = " + random_array[random_pick]);

        random_array[random_pick] = -1; // -1을 왜하는거지?
    }
A: 실제 아무런 내용 없이 사진만 있을 수 있으므로 0이 존재할 수 있음
   그러므로 0이 아닌 다른 값으로 삭제했다는 것을 알려야 하는데
   양수를 쓰면 데이터가 있는것인지 삭제된것인지 판저이 불가능함
   그러므로 음수를 사용해서 이것은 삭제된 데이터임을 판정함

Q: public void print_random_array() {
        int count = 1;

        for(int i = 0; i < random_array.length; i++) {
            if(random_array[i] == -1) {
                // 프린트할때 제외하려고 -1을 사용한건가?
                continue;
            }
            System.out.printf("%4d", random_array[i]);

            if(count % 5 == 0) {
                System.out.println("");
            }
            count++;
        }
        System.out.println("");
    }
A: 출력할 때 -1(삭제됨)인 녀석들을 제외하려고 사용한게 맞습니다.

Q: public void insert_sort() {
        int i, j, number_key, player_number_key, len = sum_of_dice.length;
        // 로직 자체를 이해하지 못한 것 같다;ㅅ; 변수명을 바꿔봐도 모르겠다~ len?이건 뭐지?
        for(i = 1; i < len; i++) {
            number_key = sum_of_dice[i];
            player_number_key = array_player[i];

            for(j = i - 1; (j != -1) && (sum_of_dice[j] > number_key); j--) {
                sum_of_dice[j + 1] = sum_of_dice[j];
                array_player[j + 1] = array_player[j];
            }

            sum_of_dice[j + 1] = number_key;
            array_player[j + 1] = player_number_key;
        }
    }
A: 일단 len 은 sum_of_dice.length 라 해서 실제 배열의 길이
   배열의 길이는 결국 플레이어의 숫자임
   플레이어들 마다 현재 합산된 점수가 있을 것이고
   그 합사된 점수를 관리하는 배열이 바로 sum_of_dice 이다.
   그러므로 이 배열에 정렬을 적용해야 한다.
   i 가 기준점
   j 는 i 보다 앞에 있는 모든 대상들
   기준점 앞에 있는 값들이 기준점보다 큰가 ?
   크다면 위치를 조정한다.

Q: boolean 의 존재의의, 왜 필요한지 모르겠다
   코딩 중 테스트용으로 연습모드 구분을 위한것인가?
A: 프로그램을 실행하는데는 크게 두 가지 패턴이 있다.
   첫 번째, 컴파일 형식의 바이너리 실행
   두 번째, 인터프리터 형식의 실시간 실행
   결국 이 두 가지에서 오는 차이점 때문에 자바가 처리하지 못하는 몇 가지 형식들이 있다.

   컴파일 형식 언어들은 처음 실행 파일을 만들때 메모리 배치,
   계산이 필요한 코드는 미리 전부 계산이 완료된 형태로 만들기 때문에 속도가 빠르다.
   반면 인터프리터 방식의 언어는 실행할 때 메모리를 배치하며
   계산을 실행하면서 해야하기 때문에 컴파일 언어 보다 속도가 느리지만 유연하다는 자점이 있다.

   예로 C 에서 동작하는 코드 if(!(i % 2)) 같은 코드가
   자바에서는 처리할 수 없는 형태가 된다(자바의 실행 자체가 위에서 언급한 인터프리터 방식이기 때문)
   그렇기 때문에 자바에서는 if(!(i % 2 == 0)) 혹은 if(i % 2 == 1)과 같은 형태로 작성해야 한다.
   결국 i % 2 == 1 이 참이냐 거짓이냐를 판별해야 하는데
   이것에 대한 자료형이 바로 boolean 인 것이다.
   오직 참과 거짓만을 값으로 가질 수 있는 변수다.

   p.s: 실제 자바는 하이브리드 방식을 취한다.
        javac 명령어가 자바 컴파일러이며 바이트 코드를 생성한다.
        java 명령어가 자바 인터프리터(JVM)이며 실시간으로 바이트 코드를 실행하며
        바이트 코드를 현재 프로그램의 머신에 적합한 기계어로 바꾸며 동작한다.


Q: case 8:
      for(int j = 0; j <= 2; j++) <<< 숫자 2 대신 변수로 처리하는 것이 더 좋음
      for(int j = 0; j < playerNum; j++) {
         if(j == i) {
            continue;
         }

         sumOfDice[j] += 3;
      }

   이 코드가 왜 자신을 제외한 모든 플레이어를 대상으로 하는 지 모르겠다.
A: 플레이어가 3 명이니까 자신을 제외한 모든 사용자들에게 버프를 준다.
   자기 자신은 현재 i 값일테니 j 값이 i 와 같아지면
   자신은 제외하고 나머지 2명의 플레이어들에게 버프를 부여한다.

Q: for 문에서 length를 적용하는 예와 그렇지 않은 예의 구분을 못하겠다
A: length의 용도를 생각하면 되는데 배열의 길이를 구할때 arr.length 형식으로 길이를 구한다.
   만약 배열의 길이만큼 반복을 해야 한다면 arr.length 는 매우 탁월한 선택이 될 것이다.
   그렇지 않은 경우에는 다른 방식을 사용해야 할 것이다.

Q: 생성자와 메소드의 차이를 정확히 구분하지 못하겠습니다.
A: 생성자와 매서드의 차이
   1) 핵심적인 차이는 리턴타입을 아예 적지 않는 다는 것
   2) 또 다른 핵심적 차이점이라면 생성자는 클래스의 이름과 동일함

Q: 참조 할 만한 메소드나 생성자 없이
   스스로 작문하기에는 개념의 이해도가 너무 낮습니다.
A: 옛날에 어떤 학자가 있었다.
   그리고 그 학자가 그 당시 최고의 수학자였던 ??? 를 찾아갔습니다.
   "어떻게 해야 빨리 효율적으로 당신같이 될 수 있나요 ?" 라고 학자가 물었습니다.
   그러자 수학자가 답하였습니다.
   "왕도가 없습니다. 그냥 될 때까지 합니다."

   추가적으로 하고 싶은 얘기라면
   지금 이제 배운지 1달도 안되었고
   만약 지금 처음부터 작문을 할 수 있는 형태라면 NASA 입사를 권장드립니다.

   결론은 빨리 무언가를 하려고 옭아매이기 보다는 여유를 가지고 천천히 꾸준히 성장하면 됩니다.
   조급할수록 돌아가란 말이 있듯이 꾸준히 하면 작은게 쌓여서 태산이 됩니다.

   케이스 1: 처음에 잘 하던 사람
   처음 내용이 쉽다보면 자만하게 됨.
   결국 시간이 지나서 다른 사람들이 열심히 할 때 자만하여 안하고 있다가 마지막에 뒤쳐짐
   즉, 처음에 잘 못했지만 빡세게 열심히 했던 사람이 끝날때 더 잘했다는 뜻입니다.

   케이스 2: 포기한 사람
   갑자기 3개월차에 가서 전부 모르겠다고 합니다.
   이러면 결국 손을 쓸 수가 없는 상태가 됩니다.
   모르겠는것이 있으면 부담갖지 않고 다 질문합니다.
   지금 해야합니다.
   지금 안하고 나중에 가서 갑자기 1주차 내용, 3주차 내용 물어보면 정말 서로 많이 힘듭니다.

평타: 최소 개인 프로젝트 완성 <<<--- 이력서 올리면 꾸준히 연락옴
상타: 팀 프로젝트 잘 뽑기 <<<--- 이력서 올리면 바로 연락옴

만약 취업 시즌이 아니라면 조금 시간이 걸리더라도 연락옵니다.

Q: ScoreCalculator[] arr 를 참조해서 getMean , getStdDeviation 이 가능한가?
A: 실제 코드에 보면 arr[i].getMean(), arr[i].getStdDeviation() 와 같은 코드들이 보일 것입니다.
   이 부분이 질문한 내용에 답이 될 것 같네요.

Q: 그렇다면 다른 해당 참조 클라스에 다른 인자들도
   get 으로 불러들일 수 있는지 있다면 그 조건은 무엇일까?
A: 입력 인자로 생성된 객체를 넘겨주면
   입력을 받은 매서드에서 언제든지 사용이 가능합니다.

Q: 왜  classArr[len - 1], mean[len - 1]);이 최고점이고
   classArr[0], stdDev[0]);이 최저점인지 이해가 안됩니다.
A: 우리가 정렬 알고리즘(insertSort()을 사용하면 오름차순으로 정렬됨)
   결국 작은 숫자는 맨 앞으로 배치되고 큰 숫자는 맨 뒤로 배치됩니다.
   그러므로 최소값을 찾는다면 맨 앞인 0 번 인덱스가 될 것이고
   최대값을 찾는다면 맨 뒤인 (배열길이 - 1)번 인덱스가 될 것입니다.

Q: cnt++가 printf에서 처음에 ++ 해서 1로 출력되서
   0번째 사용자 1번째시도 주사위눈금 n값으로 출력될듯한데
   그렇면 cnt==3일때 0으로 변환되서 끝나기때문에
   cnt는 두번 도는게 아닌가요??
A: 두 번 도는것이 맞습니다.
   물론 홀짝 처리가 올바르게 되었을 경우를 전제로 한다.

Q: 주석을 올바르게 달았는지 확인해주세요.
A:      // 처음던지면서 octahedronDice가 짝수일때 작동
        if (cnt == 1 && octahedronDice % 2 == 0) {     
            // octahedronGame가 false이므로 더이상 작동하지 않는다.
            ***** ??? 누가 더 이상 동작하지 않을까요 ? while(octahedronGame) 부분이 동작하지 않음
            octahedronGame = false; 
            // 0으로 초기화한다    
            ***** 왜 여기를 초기화 해야할까 ???
               -- 다시 던져야 하기 때문에
            ***** 결국 cnt 값이 초기화되지 않으면
            ***** 프로그램이 끝나지 않거나 잘못된 결과를 도출할 수 있음
            cnt = 0;                                  
        // 처음던졌을때 octahedronDice가 홀수라면
        // 주사위 한번 더 던지게되는데 octahedronDice 짝수라면 스위치가 작동한다.
        } else if(cnt == 2 && octahedronDice % 2 == 0) {        
                                                                
            switch (octahedronDice) {

Q: 컴퓨터에는 동시에 교체가 불가능하기 때문에 어딘가에 값을 백업해야 하는건가요 ?
A: 네 맞습니다.
   동시에 할 수 없기 때문에 교체하고자 하는 대상을 다른 변수에 백업해놓고
   작업을 처리한 이후 백업한 정보를 원하는 위치에 배치하는 형식으로 동작시킨다.

Q: 듀얼이 1이여도 작동 0이여도 작동된다고 이해가되는데 그럼 필요한 이유가 있나요???
A: 이건 제가 그냥 강제로 결투모드가 되게 만들려고 duel = true 를 설정했습니다.

Q: numOfRandom배열값을 대입한다는게 예를들면 10이 나왔을 경우 10을 대입하는건지?
   10의 배열자릿수를 대입하는건가요???
A: 공간만 10 개 만듭니다.

Q: 배열에 특정 위치를 지웠을때 어떻게 처리해야하는가 ?
A: 1) 뒤에 있는 값들을 전부 앞으로 땡깁니다.
      뒤쪽에 데이터가 많을수록 지옥이 펼쳐진다.
   2) 그냥 어디가 지워졌는지 파악만 해둔다.
      배열 인덱스 바꿀 필요 ? 없다.
      값을 이동시킬 필요 ? 없다.

Q: 이질문은 풀이에없는 질문입니다.
   코드를 작성하다보면 배열의 크기가 부족하다는 에러가 발생할때가 종종 있습니다.
   그럴경우 제가 줬던 배열의 + 1을 주니깐 해결이 되었습니다.
   그런데 이 부분이 이해가 안되고 그렇게 실행만 된다는걸 알아서 질문드립니다.
A: 일단 Out of Range 에러가 났을 경우 발생하는 오류로 판단되고요.
   + 1 을 줘서 해결이 되었다면 문제가 두 가지 정도 있습니다.
   1) 배열의 인덱스 계산을 잘못해서 할당 크기를 잘못 맞춘 경우
   2) 프로그램 동작시 논리적인 오류로 인해 범위를 벗어나게 값을 할당할 경우

Q: sumOfDice = new int[playerNum];
   부분에서 왜 sumOfDice를 playnum 배열로 했는가 ?
A: sumOfDice 라는 것이 사용자들의 누적 합산값을 관리하는 배열이므로
   각 인덱스가 사용자를 나타내는 형식으로 만들었다.
   그러므로 playNum 으로 배열을 만들면 사용자 숫자만큼 누산치를 얻을 수 있게 된다.

Q: 아래 코드에 대한 질문입니다.

RockPaperScissors(boolean duel) {
    scan = new Scanner(System.in);
    if(duel != true) {
        System.out.println("결투 모드입니다. 다음부턴 true 설정을 해주세요!");
    }
    this.duel = true;

위 if 부분 주석처리 이후 실행을 해봤는데
문제 없이 실행이되어서 설정한 이유가 무엇인가?
혹시 하단부 while(duel)과 관련이 있는 것인가요?

A: 옵션을 주면 무조건 결투 모드가 동작하도록 만들려고 했던 의도가 있습니다.
   do ~ while() 부분은 조건이 맞던 틀리던 무조건 1 번은 실행하게 됩니다.

Q: 문제6번 cnt가 아닌 octahedronOption 을 이용한 방법이 궁금합니다.
A: 코드로 만들어봅시다.
   9 회차 내용의 Homework6 자바 파일과 MyDice 자바 파일의
   playOctahedronQnA() 매서드를 살펴보도록 한다.

Q: public 이후에 static 쓰는 것에 대해 잘 모르겠습니다.
   어떤 경우에 쓰고 어떤 경우에 안쓰는건지 다시 한 번 설명 듣고 싶습니다.
A: 원래 정석이라면 클래스를 사용할 때 반드시 필요한 절차가 무엇인가요 ?
   ClassDataType 클래스변수명 = new ClassDataType(): 필요하다면 생성자 호출
   어제 사용했던 static 매서드는 이런 절차 없이도 매서드를 호출할 수 있었다.
   이유가 무엇이냐하면 원래 new 를 하는 데이터들은 모두 Heap(힙)이라는 가상 메모리 영역에 배치된다.
   new 를 하지 않는 경우엔 일반적으로 Stack(스택)이라는 가상 메모리 영역에 배치된다.
   (그리고 이 영역을 지역 변수의 영역이라고 많이들 부른다)
   static 이 붙은 녀석은 강제로 JVM이 메모리에 끌고 올라가는 녀석이다.
   그러므로 자바 프로그램이 실행될때 JVM이 죽을때까지는 계속 함께 상주해있는 상태이다.

   결론: 메모리에 올라가지 않은 데이터는 어떤 경우에도 사용할 수 없다.
        그렇기 때문에 우리가 new 를 사용해서 객체를 메모리에 할당하는 것이고
        이렇게 사용하지 않는 경우라면 static 밖에 없다.

Q: 9번 메인 함수에서 printMax(scArr) 은 객체 쓰지 않고 되어있는데
   클래스 배열 선언을 하면 이와 같이 (객체.메소드) 가 아닌 그냥 메소드를 사용하면 되는건가요?
A: 같은 클래스 내부에 있는 매서드 끼리는 서로 '클래스변수명.매서드명()' 형식으로 호출할 필요 없이
   단순히 '매서드명()' 으로 호출이 가능합니다.

Q: 12번에 calcRemainHour 메소드와 fireStop, printConversionHour2COmfortFormat()
   메소드가 잘 이해가 안돼서 다시 한번 설명 부탁드리겠습니다.
A: 코드를 다시 보니 혼동을 유발할 수 있는 형태의 매서드 구성이라 수정을 했습니다.
   rate = (rateA + rateB)로 전체 작업률을 계산한 것이고
   fireStop(rateA, 사고수습일)로 A의 작업률을 제외한
   B의 작업률만 가지고 사고수습일동안 작업한 결과를 산출합니다(즉 전체 처리할 분량에서 값이 차감됨)
   이후에 전체 비율(rate = rateA + rateB)를 가지고 마무리(날자, 시간, 분 계산) 작업을 합니다.
