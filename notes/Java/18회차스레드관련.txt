-------------------       -------------------
|     A.class     |       |     B.class     |
-------------------       -------------------

A.class에는 javac(자바 컴파일러)가
자바 코드를 컴파일하여 만든 바이트 코드가 있음
B.class도 이하 동문임

A.class를 구동시키기 위한 main()의 코드들과 매서드가 존재할 것임
B.class를 구동시키기 위한 main()의 코드들과 매서드가 존재할 것임

명령어 java는 실제로 JVM에 해당하여
만들어진 바이트 코드(*.class)파일을 읽어서
기계어로 변환하고 CPU가 이것을 실행하게 한다.

만약 A 프로세스와 B 프로세스가 두 개 존재한다면
A 프로세스의 main()과 매서드를 돌리고
B 프로세스의 main()과 매서드를 돌려야 할 것이다.

이때 CPU는 오직 한 순간에 한 가지 일만 수행한다.
그럼 어떻게 이것을 처리해야 할까 ?
적당한 시간을 주고 서로 돌아가면서 실행하게 만든다.

그럼 각각의 프로세스들은 CPU가 실행시켜야할 기계어 코드를 가지고 있지만
매순간 실행되는 것이 아닌 특정한 순간에만 이것을 실행하게 될 것이다.
(결국 프로세스들 간에 CPU를 획득하기 위한 경쟁이 발생한다)

Q: 만약 CPU 1개인 상황에서 프로세스가 서로 달라고 아우성 치면 어떻게 해야하나요 ?
A: 우선순위가 있어서 우선순위가 높은 프로세스에 시간도 실제로 더 많이 주고
   제어권도 이 녀석에게 먼저 넘어가는 형식으로 동작한다.
   
Q: 아래와 같은 코드에서 병렬 처리가 이해가 안됩니다.

싱글 코어 환경에서 동작하는 형식

c = 4        : c = 4
a = 5 + c    : a = 9
c = 3        : c = 3  ----> d = 3
b = a + c    : b = 12 ----> b = a + d

       Thread A(CPU 0)            Thread B(CPU 1)
       
       c = 4                      c = 3
       a = 5 + c                  b = a + c
       
위의 코드가 과연 올바르게 돌 수 있을까 ?

케이스 1)
A가 먼저 동작

c = 4 ---> 제어권이 B에게 넘어감

c = 3 ---> 기존의 c 값이 변경되고 제어권이 A에게 넘어감

a = 5 + c = 8 ---> 원래라면 9가 나와야 할 것이 8이 나오면서 데이터 무결성이 깨짐

b = a + c = 11 ---> 마찬가지로 의도하지 않은 이상한 결과가 나오게 되었음

현재 케이스는 에러

케이스 2)
A가 먼저 동작

c = 4
a = 5 + c ---> 9 이후에 제어권이 B에게 양도됨

c = 3
b = a + c ---> 12 정상적인 결과가 도출됨

결론: 운 좋으면 정상 동작하는데 안 좋으면 값이 꼬임
     (이게 만약 은행이면 ?)
     
     
     
     
     
     
     
     
