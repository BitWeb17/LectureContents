우리가 돌린 프로그램에서 아래와 같은 요상한 결과가 나왔다.

원금: 100000
minusMoney(1000): 99000
plusMoney(3000): 103000

정상적이라면 102000원이 나와야 하는데 왜 이렇게 나왔을까 ?
어째서 요런 요상한 결과가 나올까 ?
(이것이 바로 대표적인 동기화 문제다)

* Critical Section: 

동시에 여러 태스크가 접근할 수 있는 변수 영역을
모두 통틀어 Critical Section이라 부른다.

* Multi-Tasking

실제로는 하나 하나 수행하지만 동시에 되는 것처럼 보이는 현상

* 여러개의 CPU를 활용하는 상태에서의 Multi-Tasking

실제로 Data Dependency가 없다면
CPU는 두 개의 연산을 레알로 동시에 실행하게 된다.
문제는 CPU는 DD를 검사할 뿐
그것의 논리 오류는 검사하지 않는다는 것이다.

실제 코드상의 int m = getMoney(); 이
서로 일치하지 않는 현상이 발생할 수 있다는 뜻
저것이 money 변수로 실제 공유되는
Critical Section 이라는 것도 상기하자!

       ++                       --
    Thread A                 Thread B
                  1000
             Shared Variable

1) A가 SV에 접근해서 1000을 획득한다.
2) 연산을 수행하고 1001이 된다.
3) B가 SV에 접근해서 1001을 획득하려고 하는 도중이다.
4) A가 SV에 접근해서 1001을 획득한다.
5) A가 연산을 끝내고 1002가 된다.
6) B가 1001 획득을 완료한다.
7) B가 연산을 끝내고 1000이 된다.
8) A가 1000을 획득한다. ??? 뭐지 ?

이것을 또 다르게는 Race Condition 이라고도 부른다.





