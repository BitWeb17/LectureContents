OutputStream의 out과 PrintWriter의 writer.println()은 어떤 관계인가요 ?

FD(File Descriptor)

Unix 철학: 모든것은 파일이다.

(운영체제 및 시스템 개발자)         (일반 사용자 및 애플리케이션 개발자)
       Kernel              |               User
                           |
     fd_array[]            |           sock = Socket()
  |    표준입력    |         |     ----- sock.getOutputStream()
  |    표준출력    |         |     |     
  |    표준에러    |         |     |     write()를 얻어온
  | 사용자 데이터들 | <<<------------|    getOutputStream()에 하겠다.
         ...               |           PrintWriter의 역할
                           |           왜냐하면 println()은
                           |           내부적으로 write()를 사용하기 때문
                           |

Q: 기존에 프로그램을 해석할 때 한 파일의 main에 대한 내용들을 분석하는 형식으로 갔다.
   그러나 현재 서버 케이스에서는 두 개의 main에 대한 코드를 분석하고 있다.
   (상호 작용하고 있기 때문임)
A: 운영체제가 시분할 방식으로 프로세스들에게 CPU를 사용할 수 있는 권한을 준다.
   프로세스는 CPU의 추상화다.
   우리가 사용하는 매서드가 배치되는 가상 메모리가 text 영역이다.
   
   CPU는 오직 한 순간에 한 가지 일만 할 수 있다.
   속도가 매우 빨라서 우리가 체감하지 못할뿐
   3GHz = 1초에 진동을 30억번 한다는 뜻이다.
   쉽게 얘기해서 1초에 30억개의 명령어를 처리할 수 있다는 뜻
   
   명령어 1개 처리하는데 필요한 시간 = 1 / 30억초
   명령어 10개 처리하는데 필요한 시간 = 1 / 3억초
   ...
   명령어 10000개 처리하는데 필요한 시간 = 1 / 30만초
   명령어 10만개 처리하는데 필요한 시간 = 1 / 3만초
   
   야구 선수 탑티어가 순간 포착할 수 있는 시간 = 대략 0.3초
   이것을 멀티 태스킹이라고 한다.
   멀티 태스킹을 위해서는 컨텍스트 스위칭이란게 추가적으로 필요하지만
   자바 개발자가 여기까지 알 필요가 없으므로 이정도로 축약한다.
   
   확인 방법: ps -efx | grep 자바파일명(공통된것으로 만들면 찾기쉬움)
   서버와 소켓을 모두 띄운 경우라면 두 개가 모두 보일 것이고
   하나를 종료하면 살아있는 녀석만 보일 것이다.
   
   결론적으로 서버와 소켓이 상호작용을 하는 형시이 되므로
   이 케이스는 클라이언트가 어떤 동작을 하면
   서버가 어떻게 대응하는지의 상호작용을 분석하는 것이 중요하다.
